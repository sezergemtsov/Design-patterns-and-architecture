# Design-patterns-and-architecture

Архитектура приложений, подходы к проектированию, шаблонные конструкции - все это служит единственной задаче, упростить обслуживание приложения.
Для прозрачного и прогнозируемого внесения изменений и добавления функционала.
Все эти правила не  являются каким то непрекословным законом, и вполне можно написать приложение обходя каждое из них. Но в таком случае мы скорее всего столкнемcя с проблемами которые другие разработчики решали уже много раз. Чтобы не проделывать эту работу снова, выработан некий контракт, договоренности, которые помогут избежать большого количества проблем.

## SOLID

Самые частовстречающиеся принципы собраны в список упоминающийся под акронимом SOLID  
Это набор принципов, которые были выработаны и опубликованы разными людьми в разные периоды. Некоторые из них перекликаются друг с другом но все из них
помогут разработать удобное в обслуживании приложения.

### SRP Single responsibility principle

Как говорит название данный принцип служит для разделения области ответственности сущностей, далее будем называть их классами.
Это не значит что класс должен иметь только лишь один метод или хранить одно поле, но нужно стремиться чтобы он решал одну задачу и все детали класса
были реализованы для ее решения.

### OCP Opened-closed principle

На мой взгляд один из основных принципов подборки. Упрощенно звучит так: сущность должна быть открыта для добавления и закрыта для изменения.
То же самое другими словами: изменения в приложения вносятся посредством добавления нового кода, а не редактирования старого.
Весьма прозрачный принцип который ограничивает влияние на древо зависимостей построенного приложения. Если мы не меняем старый код, мы не ломаем дерево зависимостей

### LSP Liskov substitution principle

Принцип подстановки г-жи Лисков гласит: При наличии объекта О1 типа S, объекта O2 типа T, программы P работающей с типом T, если O1 заменен на O2 и поведение P осталось неизменным, значит S является подтипом T.  
Сначала может показаться что это принцип наследования и мы не влияем на поведение обьектов, однако это значит что при наследовании нам запрещается переопределять основные методы классов прародителей.

### ISP Interface segregation principle

Разделение интерфейсов, принцип перекликающийся с SRP, говорит также о том что интерфейс заранее следует определять под узкую область, так как он выростит древо зависимостей которое потом сложно исправлять. Вобщем чем больше интерфейсов тем лучше, но увлекаться точно не стоит.

### DIP Dependency inversion principle

Данный принцип говорит нам зависить не от конкретной сущности или реализации, а от абстракции или интерфейса. Так мы сможем вносить изменения не нарушая OCP в дальнейшем. Данный принцип наряду с OCP на мой взгляд является одним из важнейших, так как из соблюдение позволяет строить сложную открытую к изменению структуру.

Дополнительно существуют и другие принципы и правила такие как DRY(don't repeat yourself), magic numbers, KISS но они скорее похожи на табличку над рабочем местом токаря где говорится что чистое рабочее место лучше чем грязное. С этим конечно сложно спорить, но протачивать втулки эта табличка слесарю явно не помогает.

## Шаблоны проектирования

Наряду с принципами существуют определенные шаблоны построения программ. Это уже более прикладная вещь, и может встречаться и при разборе фреймворков и чужого кода. Названия не регламентированы жестко, но здесь также присутствует некий контракт, поэтому если мы встретили шаблонное название класса, то чаще всего он работает в стректуре общеизвестного шаблона, и мы заранее можем определить что он должен делать.

Шаблоны принято разделять на три группы: порождающие, структурные и поведенческие. Это можно назвать зонами их ответственности.

### Порождающие шаблоны

1. Абстрактная фабрика.  
Подробно [здесь](https://ru.wikipedia.org/wiki/Абстрактная_фабрика_(шаблон_проектирования))  
Коротко - если сущность, далее клиент, зависит от другой сущности, далее продукт, то для инициализации ряда однородных продуктов создается отдельная сущность - фабрика. Клиент использует фабрику для построения продуктов.

2. Строитель
Подробно [здесь](https://ru.wikipedia.org/wiki/Строитель_(шаблон_проектирования))  
Коротко - всмомогательная сущность для инициализации полей сложной сущности, позволяет производить инициализацию с разными комбинациями полей.

3. Фабричный метод
Подробно [здесь](https://ru.wikipedia.org/wiki/Фабричный_метод_(шаблон_проектирования))  
Коротко - схожесть с абстрактной фабрикой, но реализация интерфеса производит один едиственный продукт. Для нового продукта - новая реализация

4. Прототип
Подробно [здесь](https://ru.wikipedia.org/wiki/Прототип_(шаблон_проектирования))  
Коротко - новые сущности инициализируются путем клонирования сущности прототипа. Конструкция поддерживает Clone - Clonable

### Структурные шаблоны 

1. Адаптер
Подробно [здесь](https://ru.wikipedia.org/wiki/Адаптер_(шаблон_проектирования))  
Коротко - сущность для связи между собой двух несовмещаемых интерфейсов, не влияющая на них. Обычно - переопределением методов.

2. Мост
Подробно [здесь](https://ru.wikipedia.org/wiki/Мост_(шаблон_проектирования))  
Коротко - в плане задачи похож на адаптер, но сущность сопоставляющая интерфейсы внедряется в них. Необхадимость использования определяется на этапе проектирования для последующего быстрого внесения изменений в группу интерфейсов.

3. Компоновщик
Подробно [здесь](https://ru.wikipedia.org/wiki/Компоновщик_(шаблон_проектирования))  
Коротко - интерфейс позволяющий применять действие к группе сущностей одним вызовом

4. Декоратор
Подробно [здесь](https://ru.wikipedia.org/wiki/Декоратор_(шаблон_проектирования))  
Коротко - создается подкласс в котором добавляется новый функционал, возможно как наследование так и композиция

5. Фасад
Подробно [здесь](https://ru.wikipedia.org/wiki/Фасад_(шаблон_проектирования))  
Коротко - интерфейс верхнего уровня для управления взаимодействия со структурой интерфейсов. Пульт управления

6. Легковесный (Flyweight)
Подробно [здесь](https://ru.wikipedia.org/wiki/Приспособленец_(шаблон_проектирования))  
Коротко - вставка в структуру создания обьектов проверки наличия уже созданного с похожими свойствами. Если такой есть выдаст его

7. Прокси
Подробно [здесь](https://ru.wikipedia.org/wiki/Заместитель_(шаблон_проектирования))  
Коротко - вспомогательная сущность перехватывающая управление доступом к другому обьекту. Может включать дополнительные действия, но не должен фигурировать в основной выдаче.

### Поведенческие шаблоны

1. Цепочка обязанностей
Подробно [здесь](https://ru.wikipedia.org/wiki/Цепочка_обязанностей)  
Коротко - структура связанного списка сущностей, через которые должен проходить объект. Делай либо передай дальше.

2. Команда
Подробно [здесь](https://ru.wikipedia.org/wiki/Команда_(шаблон_проектирования))  

3. Интерпретатор
Подробно [здесь](https://ru.wikipedia.org/wiki/Интерпретатор_(шаблон_проектирования))

4. Итератор
Подробно [здесь](https://ru.wikipedia.org/wiki/Итератор_(шаблон_проектирования))  
Коротко - сущность для прохода по агрегату. Агрегат соответствует iterable

5. Посредник (Mediator)
Подробно [здесь](https://ru.wikipedia.org/wiki/Посредник_(шаблон_проектирования))

6. Хранитель (Memento)
Подробно [здесь](https://ru.wikipedia.org/wiki/Хранитель_(шаблон_проектирования))

7. Наблюдатель (Observer)
Подробно [здесь](https://ru.wikipedia.org/wiki/Наблюдатель_(шаблон_проектирования))

8. Состояние (State)
Подробно [здесь](https://ru.wikipedia.org/wiki/Состояние_(шаблон_проектирования))

9. Посетитель (Visitor)
Подробно [здесь](https://ru.wikipedia.org/wiki/Посетитель_(шаблон_проектирования))

10. Стратегия
Подробно [здесь](https://ru.wikipedia.org/wiki/Стратегия_(шаблон_проектирования))

11. Шаблонный метод
Подробно [здесь](https://ru.wikipedia.org/wiki/Шаблонный_метод_(шаблон_проектирования))
